<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="title" content="Running HA Proxy in a Docker container with Let's Encrypt - SDocker Stack Deploy" />
    <meta name="description" content="A Guide on Running HA Proxy in a Docker container with Let's Encrypt" />
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="../css/bootstrap.min.css" crossorigin="anonymous">
    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="../css/style.css">
    <title>Running HA Proxy in a Docker container with Let's Encrypt | Docker Stack Deploy - Docker Swarm Consulting and Support</title>
</head>
<body>
<header>
<nav class="navbar navbar-expand-lg navbar-dark fixed-top bg-primary">
    <a class="navbar-brand" href="/">Docker Stack Deploy</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarX" aria-controls="navbarsX" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarX">
        <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
                <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/about.html">About</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/services.html">Services</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="/contact.html">Contact</a>
        </ul>
    </div>
</nav>
</header>

<main role="main" class="container">
    <div class="container">
      <div class="row">
        <div class="col-md-12 pt-3">
          <h1>Running HA Proxy in a Docker container with Let's Encrypt</h1>
          <p>&leftarrow; <a href="../">Back to Articles</a></p>
          <hr />
          <b>This article is a work in progress...</b>
          <p>
            Running your reverse proxy to serve domain names via HA Proxy on a Docker Swarm or Kubernetes with Let's Encrypt can be a challenge. When we set off to do this,
            we had a few goals in mind:
          </p>
          <ul>
            <li>Auto-generate the certificates before they expire</li>
            <li>The ability to have virtually unlimited domain names served by the container</li>
            <li>Do not mount any volumes - so we can easily swap out the machines the containers are deployed on</li>
            <li>This should all be integrated into our CI/CD pipeline, so we can just change the HA Proxy config and push up to a git repository and the new config gets deployed</li>
          </ul>
        
          <h4>The Solution</h4>
          <p>
            In the end, we came up with a simple solution, but it does require 2 private Docker images (to avoid having mounted volumes). Here's what we did:
          </p>
          <ol>
            <li>Create a base container with HA Proxy, Let's Encrypt Certbot and all the required plugins that allow us to automatically generate certs.</li>
            <li>Use this base container to periodically build a private container which has the certificates inside it.</li>
            <li>Use the second container and push your HA Proxy config file into it, deploy it to Docker Hub to Quay.io, and let a webhook deploy your updated configuration.</li>
          </ol>
          <p>
            Because we use Certbot plugins and build the Docker images in Circle CI, our only limitation is that our domains' DNS be served by either Cloudflare, Linode, Route 53, or Google.
          </p>

          <h4>Let's Docker Stack Deploy</h4>
          <h5>Step 1: The base container with HA Proxy, Certbot and all the required Plugins</h5>
          <p>
            We've already done this, so you can simply pull the container from <a href="https://hub.docker.com/r/vesica/haproxy-certbot" target="_blank">vesica/haproxy-cerbot:latest</a>. You can also see the Dockerfile @ <a href="https://github.com/vesica/haproxy-certbot" target="_blank">https://github.com/vesica/haproxy-certbot</a>.
          </p>

          <h5>Step 2: Build the container that has all the certificates</h5>
          <p>
            Let's say you will be serving DNS for all your domains via Cloudflare. You will first need to create a .ini file with your Cloudflare API credentials, so Certbot can communicate with it.
            Create a file called <code>cloudflare.ini</code> with the following:
          </p>
          <pre>
            # cloudflare.ini

            dns_cloudflare_email = your@cloudflare.account.email
            dns_cloudflare_api_key = __API_KEY__
          </pre>
          <p>
            Please do replace __API_KEY__ with your actual Cloudflare API key.
          </p>
          <p>
              Now let's create the <code>Dockerfile</code> for the container that will have the certificates:
            <pre>
              # Dockerfile

              FROM vesica/haproxy-certbot:latest

              COPY cloudflare.ini /etc/cloudflare/cloudflare.ini

              RUN mkdir -p /etc/letsencrypt/merged-ssl/domain1.com/
              RUN touch /etc/letsencrypt/merged-ssl/domain1.com/domain1.com.pem

              ### CERTIFICATES TO ISSUE - ADD ANY NEW ONES AT THE BOTTOM

              RUN certbot certonly --dns-cloudflare --dns-cloudflare-credentials /etc/cloudflare/cloudflare.ini --dns-cloudflare-propagation-seconds 60 --non-interactive --agree-tos --email your@email.com \
              -d domain1.com \
              -d *.domain1.com \
              -d domain2.net \
              -d domain3.org \
              -d www.domain4.co.uk 

              ### DO NOT CHANGE ANYTHING ELSE ###

              COPY startup.sh /usr/local/bin/startup
              RUN chmod 755 /usr/local/bin/startup

              ENTRYPOINT ["startup"]

              CMD ["haproxy", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
            </pre>
          </p>
          <p>
            Let's go through the above Dockerfile and point our some of the finer points:
          </p>
            <ul>
              <li>We start by copying our cloudflare credentials file into the container.</li>
              <li>We create the directory and file where we will store the certificates for all the domains.
                  <b>Note</b> that <code>domain1.com</code> should be replaced with whatever is the first domain in the list of domains you
                  are generating certificates for.
              </li>
              <li>The rest is copying over a startup.sh file to start HA Proxy. We create this file below.</li>
            </ul>
          <p>
              Let's create the <code>startup.sh</code> file which will put the certificates in the right folder and start HA Proxy when the container runs.
              Add the following code to a file called <i>startup.sh</i>.
          </p>
          <pre>
            # startup.sh

            #!/bin/sh

            ## Put certs in usable place. Pay attention to domain1.com, that must always be the first domain. Otherwise change the below accordingly and haproxy.cfg too.
            cat /etc/letsencrypt/live/domain1.com/fullchain.pem /etc/letsencrypt/live/domain1.com/privkey.pem > /etc/letsencrypt/merged-ssl/domain1.com/domain1.com.pem

            # Start HA Proxy
            set -e

            # first arg is `-f` or `--some-option`
            if [ "${1#-}" != "$1" ]; then
              set -- haproxy "$@"
            fi

            if [ "$1" = 'haproxy' ]; then
              shift # "haproxy"
              # if the user wants "haproxy", let's add a couple useful flags
              #   -W  -- "master-worker mode" (similar to the old "haproxy-systemd-wrapper"; allows for reload via "SIGUSR2")
              #   -db -- disables background mode
              set -- haproxy -W -db "$@"
            fi

            exec "$@"
          </pre>

          <p>
            With the Dockerfile and startup.sh in place, let's build this container. Run <code>docker build . -t haproxy-certs:latest</code>.
          </p>

          <h5>Step 3: Build the container with the HA Proxy configuration</h5>
            <p>
                To build this container, we need to create a <code>Dockerfile</code> and an <code>haproxy.cfg</code> file.
                Let's start with the Dockferfile.
            </p>
            <pre>
              # Dockerfile

              FROM haproxy-certs:latest

              COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg
            </pre>

            <p>
              Now let's create our <code>haproxy.cfg</code> file.
            </p>
            <pre>
              # haproxy.cfg

              #### MAKE CHANGES HERE ONLY IF YOU REALLY KNOW WHAT YOU ARE DOING #####
              #---------------------------------------------------------------------
              # Global settings
              #---------------------------------------------------------------------
              global
                daemon
                maxconn 10000
                tune.ssl.default-dh-param 2048

              #---------------------------------------------------------------------
              # common defaults that all the 'listen' and 'backend' sections will
              # use if not designated in their block
              #---------------------------------------------------------------------

              defaults

                mode                    http
                log                     global
                option                  dontlognull
                option                  http-server-close
                option                  redispatch
                retries                 3
                timeout http-request    1m
                timeout queue           1m
                timeout connect         10s
                timeout client          1m
                timeout server          1m
                timeout http-keep-alive 10s
                timeout check           10s
                maxconn                 10000

              frontend haproxy-manager
                bind :::10000 v4v6
                mode http
                stats enable
                stats auth username:password
                stats refresh 15s
                stats show-node
                stats uri /haproxy-admin
                stats admin if TRUE

              frontend http-in
                bind :80 v4v6
                bind :::80 v6only
                bind :443 v4v6 ssl crt /etc/letsencrypt/merged-ssl/domain1.com/domain1.com.pem
                bind :::443 v6only ssl crt /etc/letsencrypt/merged-ssl/domain1.com/domain1.com.pem
                option forwardfor
                http-request set-header X-Forwarded-Proto https if { ssl_fc }
                http-request set-header HTTPS on if { ssl_fc }
                http-request set-header Ssl-Offloaded 1 if { ssl_fc }

              ## Define hosts
                acl host_domain1.com hdr(host) -i domain1.com

              ## Figure out which backend they will use
                use_backend domain1.com if host_domain1.com

              default_backend default

              backend default
                server w1 swarm-worker-1:port cookie S1 check
                server w2 swarm-worker-2:port cookie S1 check
                server w3 swarm-worker-3:port cookie S1 check

              backend domain1.com
                server w1 swarm-worker-1:port cookie S1 check
                server w2 swarm-worker-2:port cookie S1 check
                server w3 swarm-worker-3:port cookie S1 check
            </pre>

          <h5>Step 4: A Docker Stack file to get you started</h5>
        </div>
      </div>

      <hr />

    </div> <!-- /container -->

</main>

<footer class="footer">
    <div class="container">
      <p>Articles on this website are &copy; <a href="https://vesica.co.uk" target="_blank">Vesica</a> 2019. Docker is a trademark of Docker, Inc.</p>
    </div>
  </footer>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
</body>
</html>
